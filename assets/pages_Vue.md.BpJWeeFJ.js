import{_ as s,c as i,o as a,a3 as t}from"./chunks/framework.BI06Adbe.js";const e="/assets/10.D8dzqt0h.png",n="/assets/11.DI0-ntbO.png",l="/assets/14.Dfl7eWuq.png",h="/assets/15.uDyCeGW-.png",p="/assets/16.Ce9-NxNG.png",r="/assets/18.CXXhW2Ll.png",o="/assets/19.DSP6W-64.png",k="/assets/20.BsDRaCAG.png",d="/assets/21.DQXsdIFO.png",g="/assets/22.BHqlnP3y.png",D=JSON.parse('{"title":"Vue2&Vue3相关","description":"","frontmatter":{},"headers":[],"relativePath":"pages/Vue.md","filePath":"pages/Vue.md"}'),u={name:"pages/Vue.md"},c=t(`<h2 id="vue2" tabindex="-1">Vue2 <a class="header-anchor" href="#vue2" aria-label="Permalink to &quot;Vue2&quot;">​</a></h2><h2 id="生命周期钩子函数" tabindex="-1">生命周期钩子函数 <a class="header-anchor" href="#生命周期钩子函数" aria-label="Permalink to &quot;生命周期钩子函数&quot;">​</a></h2><blockquote><ul><li>初始化前后、dom渲染前后、数据更新dom更新前后、组件销毁先后</li><li><strong>created</strong> (可以开始发送ajax请求，获取data内的数据，保存数据)</li><li><strong>mounted</strong> （可以开始操作dom例如初始化echarts）</li></ul></blockquote><ol><li><strong>beforeCreate</strong>：data数据初始化之前，组件还没有数据</li><li><strong>created</strong>: data数据初始化之后，可以获取到组件的数据</li><li><strong>beforeMount</strong>：DOM渲染之前，DOM还没渲染</li><li><strong>mounted</strong>：DOM渲染之后，可以操作DOM了</li><li><strong>beforeUpdate</strong>: 数据更新，DOM更新前</li><li><strong>updated</strong>: 数据更新，DOM更新后</li><li><strong>beforeDestroy</strong>: 组件销毁前</li><li><strong>destroyed</strong>: 组件销毁后</li></ol><h2 id="vue-的父组件和子组件生命周期钩子函数执行顺序" tabindex="-1">Vue 的父组件和子组件生命周期钩子函数执行顺序 <a class="header-anchor" href="#vue-的父组件和子组件生命周期钩子函数执行顺序" aria-label="Permalink to &quot;Vue 的父组件和子组件生命周期钩子函数执行顺序&quot;">​</a></h2><div class="language-text vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">text</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>1、Vue 的父组件和子组件生命周期钩子函数执行顺序可以归类为以下 4 部分：</span></span>
<span class="line"><span>  1）加载渲染过程</span></span>
<span class="line"><span>     父 beforeCreate -&gt; 父 created -&gt; 父 beforeMount -&gt; 子 beforeCreate -&gt; 子 created -&gt; 子 beforeMount -&gt; 子 mounted -&gt; 父 mounted</span></span>
<span class="line"><span>  2）子组件更新过程</span></span>
<span class="line"><span>     父 beforeUpdate -&gt; 子 beforeUpdate -&gt; 子 updated -&gt; 父 updated</span></span>
<span class="line"><span>  3）父组件更新过程</span></span>
<span class="line"><span>     父 beforeUpdate -&gt; 父 updated</span></span>
<span class="line"><span>  4）销毁过程</span></span>
<span class="line"><span>  父 beforeDestroy -&gt; 子 beforeDestroy -&gt; 子 destroyed -&gt; 父 destroyed</span></span></code></pre></div><h2 id="响应式原理" tabindex="-1">响应式原理 <a class="header-anchor" href="#响应式原理" aria-label="Permalink to &quot;响应式原理&quot;">​</a></h2><ul><li><p>双向数据绑定采用了数据劫持来实现，通过Object.defineProperty()来劫持各个属性的 setter 和 getter，从而实现了数据的响应式更新。getter 方法用于获取数据，setter 方法用于监听数据的变化并更新数据。</p></li><li><p><strong>缺陷</strong>是只能对data节点内定义的数据进行数据劫持，不能监听对象的新增属性和删除属性。</p></li><li><p>vue更新数组不能通过索引，可通过pop、push、shift、unshift、splice、sort、reverse来实现。</p></li><li><p><strong>解决</strong>缺陷的方法通过 Vue.set() 或者 this.$set() 来<strong>添加</strong>新属性，也可以<strong>监听</strong>数组的变化，<strong>需要手动调用</strong></p><p><img src="`+e+'" alt="image-20230830235650813"></p></li></ul><p><img src="'+n+'" alt="image-20230830235407649"></p><h2 id="为什么data是一个函数而不是对象" tabindex="-1">为什么data是一个函数而不是对象 <a class="header-anchor" href="#为什么data是一个函数而不是对象" aria-label="Permalink to &quot;为什么data是一个函数而不是对象&quot;">​</a></h2><blockquote><p>如果是一个对象的话，组件被<strong>多次使用</strong>，里面的对象的数据存储的是在<strong>一个地址</strong>里面的，如果修改数据，其他组件里面的数据也会被修改，造成<strong>数据污染</strong>；采用函数的形式就不会出现这种情况，每一次创建的时候，函数都会<strong>return</strong>一个<strong>新的对象</strong>，因为每个对象的<strong>地址不同</strong>。</p></blockquote><h2 id="vue3" tabindex="-1">Vue3 <a class="header-anchor" href="#vue3" aria-label="Permalink to &quot;Vue3&quot;">​</a></h2><h2 id="生命周期钩子函数-1" tabindex="-1">生命周期钩子函数 <a class="header-anchor" href="#生命周期钩子函数-1" aria-label="Permalink to &quot;生命周期钩子函数&quot;">​</a></h2><blockquote><ul><li><strong>onMounted</strong>：组件渲染完毕：发请求，操作dom，初始化图表</li><li><strong>onUnmounted</strong>：组件卸载后，清除定时器、延时器、事件监听等等</li></ul></blockquote><ol><li><p>setup：函数是在组件实例被创建之前调用的，它是使用 Composition API 的入口点。</p></li><li><p>onBeforeMount: 在挂载开始之前被调用。</p></li><li><p>onMounted: 在挂载完成后被调用。</p></li><li><p>onBeforeUpdate: 在更新开始之前被调用，这里可以拿到新的 props 和 reactive 数据。</p></li><li><p>onUpdated: 在更新完成之后被调用。</p></li><li><p>onBeforeUnmount: 在卸载之前被调用。</p></li><li><p>onUnmounted: 在卸载之后被调用。</p></li><li><p>选项api和组合api名字不一样</p><p><img src="'+l+'" alt=""></p></li></ol><h2 id="响应式原理-1" tabindex="-1">响应式原理 <a class="header-anchor" href="#响应式原理-1" aria-label="Permalink to &quot;响应式原理&quot;">​</a></h2><blockquote><p>vue3使用了<strong>Proxy</strong>，是对于<strong>整个</strong>对象的劫持，对象内部要是发生了变化，都会经<strong>过外层的proxy</strong>，<strong>无需递归，效率高。对于数组也是如此</strong>。</p></blockquote><p><img src="'+h+'" alt="image-20230831001543507"></p><h2 id="父通过ref或者通过-parent获取组件上的数据必须要defineexpose-暴露才能取到" tabindex="-1">父通过ref或者通过$parent获取组件上的数据必须要<strong>defineExpose</strong> 暴露才能取到 <a class="header-anchor" href="#父通过ref或者通过-parent获取组件上的数据必须要defineexpose-暴露才能取到" aria-label="Permalink to &quot;父通过ref或者通过$parent获取组件上的数据必须要**defineExpose** 暴露才能取到&quot;">​</a></h2><p><img src="'+p+`" alt="image-20230907214027096"></p><h1 id="vue2-vue3相关" tabindex="-1">Vue2&amp;Vue3相关 <a class="header-anchor" href="#vue2-vue3相关" aria-label="Permalink to &quot;Vue2&amp;Vue3相关&quot;">​</a></h1><h2 id="vue2和vue3的区别" tabindex="-1">vue2和vue3的区别 <a class="header-anchor" href="#vue2和vue3的区别" aria-label="Permalink to &quot;vue2和vue3的区别&quot;">​</a></h2><ul><li>性能优化，更快的初始化时间、渲染性能以及更新性能</li><li>响应式原理优化</li><li>更好的TS支持</li><li>组合式API的支持，省去this的指向</li><li>多个根节点</li><li>生命周期函数变化，可以有多个相同的生命周期，用setup代替了v2的前两个生命周期函数</li></ul><h2 id="vue的优点是什么" tabindex="-1">Vue的优点是什么 <a class="header-anchor" href="#vue的优点是什么" aria-label="Permalink to &quot;Vue的优点是什么&quot;">​</a></h2><ul><li>响应式数据绑定：当数据发生变化时，视图自动更新，提高了开发效率。</li><li>组件化开发：将一个页面拆分成多个组件，每个组件具有自己的逻辑和样式，便于代码的维护和重用。</li><li>轻量高效：轻量级的框架，体积小、性能高，加载速度快，能够快速构建响应式的单页面应用。</li><li>生态丰富：有大量的第三方库和插件，能够快速地解决各种问题，如数据管理、路由管理、UI 组件库等。</li><li>用户群体大：大量的文章、视频和教程，能够帮助开发者快速解决问题和提高开发效率。</li></ul><h2 id="v-if和v-for为什么不建议一起用" tabindex="-1">v-if和v-for为什么不建议一起用 <a class="header-anchor" href="#v-if和v-for为什么不建议一起用" aria-label="Permalink to &quot;v-if和v-for为什么不建议一起用&quot;">​</a></h2><blockquote><p>VUE2中v-for优先级高，所以不建议一起用 VUE3中v-if优先级高，不需要在意了</p></blockquote><ul><li>因为v-for的优先级比v-if高，一起用的情况下会优先进行v-for的遍历，然后在看v-if的布尔值，这样如果布尔值是false的情况下，会先渲染出来，再销毁，就会带来性能方面的浪费，避免这种情况的话可以在外层套个template标签，因为这个标签渲染不会生成dom节点</li></ul><h2 id="object-defineproperty-和-proxy的差异" tabindex="-1">Object.defineProperty 和 proxy的差异 <a class="header-anchor" href="#object-defineproperty-和-proxy的差异" aria-label="Permalink to &quot;Object.defineProperty 和 proxy的差异&quot;">​</a></h2><ul><li>Object.defineProperty 是对于对象属性的劫持, 需要⼀个个递归劫持, 效率低</li><li>Object.defineProperty 对于数组的更新检测, ⽐较麻烦，需要使用数组API更新才能被检测到</li><li>proxy是对整个对象的代理。只要访问了对象的属性，就会经过代理，触发相应的操作。</li><li>proxy对于数组的变化检测更为简单，不需要特殊处理数组的方法。任何修改数组的操作都能被捕获到，包括数组元素的增加、删除和更改。</li></ul><h2 id="虚拟dom-diff算法-vue中的key" tabindex="-1">虚拟DOM|diff算法|vue中的key <a class="header-anchor" href="#虚拟dom-diff算法-vue中的key" aria-label="Permalink to &quot;虚拟DOM|diff算法|vue中的key&quot;">​</a></h2><ul><li><p>虚拟dom是一个用JavaScript对象表示Web页面的概念，通过对比实际DOM的变化来提高页面性能和交互体验，并使代码更加易于管理和维护。</p></li><li><p>vue中的key是使用v-for遍历数据时，key作为vue中对比算法的标识，为了在进行虚拟 DOM 的比对时，方便 Vue 找到对应的节点，在数据修改后，vue会根据新数据生成新的虚拟DOM。对比下来虚拟DOM与真实DOM有差异的话会替换掉真实DOM。虚拟DOM没变的话就直接使用之前的真实DOM。若在旧的虚拟DOM中没有找到与新虚拟DOM相同的key，则会创建一个真实DOM进行渲染。</p><p><strong>总之</strong>，key 属性的作用是为了帮助 Vue 进行虚拟 DOM 的比对，<strong>减少不必要的 DOM 操作，提高页面渲染效率</strong>。</p><p>这个<strong>key必须是唯一值</strong>，若使用数组下标则在数组中插入或者前增会出现<strong>错乱</strong>的问题。</p></li></ul><h2 id="watch和computed区别" tabindex="-1">watch和computed区别 <a class="header-anchor" href="#watch和computed区别" aria-label="Permalink to &quot;watch和computed区别&quot;">​</a></h2><blockquote><p>computed能完成的watch都能完成，watch可以写异步代码，computed不行！</p></blockquote><ul><li>watch：是一个侦听器，当数据发生变化时，会依赖于依赖于现有的数据的值并派生出新的数据的值，当要监听复杂数据类型时需要开启深度监听。复杂数据类型需要开启深度监听deep:true，还可以添加immediate:true 开启首次监听</li><li>computed：是计算属性，有缓存，不能和data中的数据重名，比方说动态控制封装的弹窗的标题，可以通过computed来实现。</li></ul><h2 id="watch和computed的原理" tabindex="-1">watch和computed的原理 <a class="header-anchor" href="#watch和computed的原理" aria-label="Permalink to &quot;watch和computed的原理&quot;">​</a></h2><ul><li>当Vue组件实例化时，Vue会遍历<code>watch</code>选项中的每个属性，将它们转化为观察者（Watcher）对象，包含了两个主要函数：<code>getter</code>和<code>setter</code>。getter函数用于收集依赖，并添加到依赖收集器中，setter通知依赖收集器中的观察者对象，告诉它们需要更新视图，观察者对象会执行相应的回调函数来更新视图。</li><li>当Vue组件实例化时，Vue会遍历<code>computed</code>选项中的每个计算属性，计算属性的值会被缓存起来，只有在其依赖的响应式数据属性发生变化时，才会重新计算。Vue会在计算属性的<code>getter</code>函数执行时进行依赖追踪，记录哪些响应式数据属性被计算属性所依赖。当依赖的响应式数据属性发生变化时，计算属性的缓存会被标记为过期，下次访问计算属性时会重新计算，并将新值缓存起来。计算属性的值是惰性求值的，它只会在需要的时候才计算，并且只计算一次，然后进行缓存，以提高性能。</li><li>总结：监听器和计算属性都依赖于Vue.js的响应式数据系统，通过依赖追踪和观察者模式来实现数据变化的监听和响应。这种机制使Vue能够高效地更新视图以及处理复杂的数据依赖关系。</li></ul><h2 id="混入" tabindex="-1">混入 <a class="header-anchor" href="#混入" aria-label="Permalink to &quot;混入&quot;">​</a></h2><ul><li>vue2中的混入在一个js文件中写和vue export default一样 例如</li><li>export default{ data(){return{}},created()</li><li><strong>使用方法</strong>：先导入写的js文件， 再在.vue文件中的export default内写 mixins: [导入的名字],即可直接使用</li><li><strong>说明</strong>：<strong>data</strong>数据字段，<strong>methods</strong>内的方法重名，<strong>自己</strong>的<strong>高于混入</strong>的，<strong>同字</strong>段名<strong>自己</strong>的<strong>覆盖混入</strong>的</li><li><strong>生命周期</strong>函数都会执行，<strong>先</strong>执行<strong>混入</strong>的，<strong>后</strong>执行<strong>自己</strong>的</li><li><strong>优点</strong>：封装复用</li><li><strong>缺点</strong>：数据来源不清晰，后期维护性差</li></ul><h2 id="组件通信" tabindex="-1">组件通信 <a class="header-anchor" href="#组件通信" aria-label="Permalink to &quot;组件通信&quot;">​</a></h2><ul><li><strong>父传子</strong>：冒号传参props接收 父获取子：给子组件ref</li><li><strong>子传父</strong>：this.$emit(&#39;绑定在子组件上的方法名&#39;,id); //id是传的参数 ；</li><li><strong>子获取父</strong>： $parent进行传递 慎用。嵌套组件时需要要多个$parent ，跟写的位置有关</li><li><strong>祖先与后代：</strong> Provide 与 Injectc</li><li>**复杂关系：**通过vuex/pinia存放共享的变量</li></ul><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">#vue3 事件总线简单方法</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">npm i mitt</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">#在src创建个bus文件夹，内放个index.js</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//引入mitt插件:mitt一个方法,方法执行会返回bus对象</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> mitt </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;mitt&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> $bus</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> mitt</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> default</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> $bus;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">#在组件内导入使用</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> $bus </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;@/bus&#39;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">$bus.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">emit</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;cp1-send&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, data)#发布</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">$bus.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">on</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;cp1-send&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">data</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {#接收</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(data)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">})</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">#vue2 在src创建个bus文件夹，内放个index.js</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Vue </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;vue&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 创建一个空的 Vue 实例作为事件总线</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> EventBus</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Vue</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> default</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> EventBus;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">#在组件内导入使用</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> EventBus </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;./EventBus&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">EventBus.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">$emit</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;send-data&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Data from Component A&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);#发布</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">#接收		监听事件，在组件创建时就开始监听</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> mounted</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() { </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">     EventBus.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">$on</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;send-data&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">data</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">         console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(data)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">     });</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span></code></pre></div><h2 id="组件缓存keep-alive" tabindex="-1">组件缓存keep-alive <a class="header-anchor" href="#组件缓存keep-alive" aria-label="Permalink to &quot;组件缓存keep-alive&quot;">​</a></h2><blockquote><p>用于缓存不活动的组件实例，以避免在组件切换时反复创建和销毁组件实例，从而提高性能和用户体验。</p></blockquote><ul><li>用他包裹组件时，会缓存不活动的组件实例，而不是销毁，在组件的切换过程中将状态保留到内存中，防止重复渲染DOM，可以减少加载事件及性能消耗，提升用户体验。有<strong>两个生命周期函数</strong>，<strong>activated激活状态</strong>的生命周期函数 <strong>deactivated 失活状态</strong>的生命周期钩子函数。</li><li><strong>原理</strong>是通过created函数将需要缓存的VNode 节点保存在this.catch中，在页面渲染时再从this.catch中取出相应的节点并渲染</li></ul><h2 id="路由" tabindex="-1">路由 <a class="header-anchor" href="#路由" aria-label="Permalink to &quot;路由&quot;">​</a></h2><ul><li>本质上是映射关系，根据不同的URL请求，返回对应不同的资源，那么url地址和真实的资源之间就有一种对应的关系就是路由</li><li><strong>作用</strong>是设定访问路径，并将路径和组件映射起来（就是用于局部刷新页面，不需要请求服务器来切换页面）</li><li>静态路由：将不需要权限就能访问的页面称为静态路由 比如登录页 404页面</li><li>动态路由：两种：需要权限才能访问的页面</li><li>params传参：需要在路由页面配置path: &#39;/user/<strong>:a</strong>/<strong>:b</strong>&#39;,获取通过route.params.a</li><li>query传参：router.push(&#39;/user?id=123&#39;);</li></ul><h2 id="nexttick" tabindex="-1">$nextTick <a class="header-anchor" href="#nexttick" aria-label="Permalink to &quot;$nextTick&quot;">​</a></h2><ul><li>Vue在更新DOM时是异步执行的，当数据变化时，通过nextTick开启个异步更新队列，等数据更新完毕后，再进行更新视图</li><li>原理是利用了Promise、MutationObserver、setTimeout，根据环境支持情况选择最合适的异步机制来执行回调更新DOM</li></ul><h2 id="native" tabindex="-1">.native <a class="header-anchor" href="#native" aria-label="Permalink to &quot;.native&quot;">​</a></h2><ul><li>某些组件绑定点击事件不成功需要添加.native修饰符，因为组件内部没有做处理，使用修饰符后就作用到了组件的根元素上</li></ul><h2 id="vuex是数据集中管理工具" tabindex="-1">vuex是数据集中管理工具 <a class="header-anchor" href="#vuex是数据集中管理工具" aria-label="Permalink to &quot;vuex是数据集中管理工具&quot;">​</a></h2><ul><li><strong>State</strong>：用来存数据</li><li><strong>Getter</strong>：类似计算属性，基于state内的数据派生出新的数据，当state内依托的数据变了才会重新计算。</li><li><strong>mutations</strong>: 修改共享数据的唯一节点 此方法内的函数的第一个参数是state。</li><li><strong>Actions</strong>：涉及到异步操作，比如发请求要放在actions中，在actions中修改数据需要调用mutations中的方法 action中方法的第一个参数是context，里面有commit方法，通过这个方法修改context.commit(&#39;写在mutations中的方法&#39;,传的参数)</li><li><strong>Modules</strong>：模块化路由导入的地方。每一个模块的路由必须开启namespaced：true</li></ul><h2 id="为什么有了localstorage还要用vuex" tabindex="-1">为什么有了localstorage还要用vuex <a class="header-anchor" href="#为什么有了localstorage还要用vuex" aria-label="Permalink to &quot;为什么有了localstorage还要用vuex&quot;">​</a></h2><ul><li><code>Vuex</code> 主要用于在应用程序内共享和管理数据，确保数据在各个组件之间一致。</li><li>localStorage 存的只能是字符串，如果存储的内容不是字符串，还需要转换，有额外的性能消耗。</li><li>localStorage 里面的数据变化不能进行监控</li><li>主要用途就是可以响应式的处理数据</li></ul><h2 id="vuex仓库值初始化数据比较复杂时-state可以是函数写法" tabindex="-1">vuex仓库值初始化数据比较复杂时，state可以是函数写法 <a class="header-anchor" href="#vuex仓库值初始化数据比较复杂时-state可以是函数写法" aria-label="Permalink to &quot;vuex仓库值初始化数据比较复杂时，state可以是函数写法&quot;">​</a></h2><p><img src="`+r+`" alt="image-20230901010816954"></p><h2 id="vuex辅助函数" tabindex="-1">vuex辅助函数 <a class="header-anchor" href="#vuex辅助函数" aria-label="Permalink to &quot;vuex辅助函数&quot;">​</a></h2><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { mapState, mapGetters, mapMutations, mapActions } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;vuex&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> default</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  computed: {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    ...</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">mapState</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;storeA&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, [</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;countA&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]), </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 映射 storeA 中的 countA 到计算属性</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    ...</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">mapGetters</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;storeA&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, [</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;doubleCountA&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]), </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 映射 storeA 中的 doubleCountA 到计算属性</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  methods: {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    ...</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">mapMutations</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;storeA&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, [</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;incrementA&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]), </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 映射 storeA 中的 incrementA  到方法</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    ...</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">mapActions</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;storeA&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, [</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;asyncIncrementA&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]), </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 映射 storeA 中的 asyncIncrementA  到方法</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span></code></pre></div><h2 id="pinia与vuex" tabindex="-1">pinia与vuex <a class="header-anchor" href="#pinia与vuex" aria-label="Permalink to &quot;pinia与vuex&quot;">​</a></h2><blockquote><p>pinia仓库支持Composition API 风格，更好的支持TS，不再有modules的嵌套结构，也没有命名空间的概念，不需要记住复杂的关系</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> useCounterStore</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> defineStore</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;counter&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> count</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ref</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> increment</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    count.value</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { count, increment }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">})</span></span></code></pre></div></blockquote><h2 id="路由的hash跟history模式" tabindex="-1">路由的hash跟history模式 <a class="header-anchor" href="#路由的hash跟history模式" aria-label="Permalink to &quot;路由的hash跟history模式&quot;">​</a></h2><ul><li>hash：兼容性好，url中带有#，可以监听hashchange事件来获取到新旧路由地址，e.newURL,e.oldURL</li><li>history：没有#，美观，但需要后端支持，url改变会触发popState事件</li></ul><h2 id="自定义指令控制图片加载失败时显示默认图片" tabindex="-1">自定义指令控制图片加载失败时显示默认图片 <a class="header-anchor" href="#自定义指令控制图片加载失败时显示默认图片" aria-label="Permalink to &quot;自定义指令控制图片加载失败时显示默认图片&quot;">​</a></h2><p>自定义指令生命周期：</p><ul><li><code>bind</code>：在元素与指令绑定时执行，只执行一次。</li><li><code>inserted</code>：在元素插入到 DOM 后执行。</li><li><code>update</code>：在包含指令的元素更新时执行。</li><li><code>componentUpdated</code>：在包含指令的元素及其子元素都更新后执行。</li></ul><p><img src="`+o+'" alt="image-20231120152229542"></p><h2 id="图片懒加载" tabindex="-1">图片懒加载 <a class="header-anchor" href="#图片懒加载" aria-label="Permalink to &quot;图片懒加载&quot;">​</a></h2><blockquote><p>将图片真实地址存到data-src属性上 ==》 判断图片是否在可视区域 ==》 如果在，就设置图片src</p><ul><li>通过IntersectionObserver实例来检测元素是否进入视口，参数是一个函数，函数有两个参数分别是entries和接收IntersectionObserver的实例，entries是多个被观察者元素信息组合成的数组，然后对每一个被观察者信息进行遍历，如果进入视口，那么就将元素的src属性替换为data-src属性，并停止该元素的检测，避免重复加载</li><li>先实例化IntersectionObserver，然后再调用observer.observe(el)传入绑定的元素 先声明再使用</li></ul></blockquote><p><img src="'+k+'" alt="image-20230903225849685"></p><blockquote><p>注：此处el.src=binding.value与el.src=el.dataset.src相等 因为使用的时候即设置了:data-src又给自定义指令传了值</p></blockquote><h2 id="插槽" tabindex="-1">插槽 <a class="header-anchor" href="#插槽" aria-label="Permalink to &quot;插槽&quot;">​</a></h2><ul><li>用于动态地传递和渲染内容。主要目的是允许你在一个组件中定义可替换的内容，并在组件实例化时动态填充这些内容。</li></ul><p><img src="'+d+'" alt="image-20230901001638716"></p><p><img src="'+g+'" alt="image-20230901001654630"></p>',75),E=[c];function y(m,b,F,v,f,x){return a(),i("div",null,E)}const A=s(u,[["render",y]]);export{D as __pageData,A as default};
